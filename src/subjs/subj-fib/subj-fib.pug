extends ../../layout

block content
    style(type='text/css').
        .snippet {
            color: #f0f0f0;
            background-color: #404040
        }

    p How can we solve Fibonacci number as fast as possible?

    pre.alert-info.
        - Code examples here are written in Python.
    
    .sub-title Recursion

    p The most natural way to do this is using recursive function calls:

    pre.snippet.
        def fib(x):
            if x == 0:
                return 0
            elif x == 1:
                return 1
            else:
                return fib(x - 1) + fib(x - 2)

    p If we treat an addition as the basic calculation unit, we get an interesting conclusion: time complexity T(n) = O(fib(n - 1)) = O(1.618^n). Considering function call overheads in addition, this method is rather inefficient.
    
    .sub-title Iteration

    p If we simply transform the recursion to iteration, the time complexity reduces to linear T(n) = O(n):

    pre.snippet.
        def fib(x):
            a = 0
            b = 1
            for i in range(2, x + 1):
                b = a + b
                a = b - a
            return b

    p Can it be even faster?
    
    .sub-title Formula

    p There is a general formula for Fibonacci number calculation, with which it's easy to write the code:

    pre.snippet.
        def fib(x):
            sqrt5 = 5 ** 0.5
            return int(1 / sqrt5 * (((1+sqrt5) / 2) ** x - ((1-sqrt5)/2) ** x))

    p It seems to be a O(1) solution, since pow(x, y) is of O(1) on modern CPU architectures. But if the number is too large, we have to implement the exponentiation manually. Luckily, there is a method called "exponentiation by squaring"（快速幂）, based on a divide-and-conquer strategy, that we can use to achieve O(log(n)) complexity. 
    
    .sub-title Matrix

    p Can we avoid floating point calculation, while keeping the O(log(n)) time complexity? The answer is yes:

    img(src='./fib_matrix.png', width='60%')

    p To get the value of f(n), we need to perform exponentiation on the matrix, and obtain the first element of the result. With the same divide-and-conquer idea, this can be optimized to O(log(n)) as well.
    
    p Code:

    pre.snippet.
        import numpy as np

        def fib(x):
            result = np.array([[0, 1], [0, 1]])
            power = np.array([[1, 1], [1, 0]])

            while (x):
                if x & 1:
                    result = result.dot(power)

                x = x >> 1
                power = power.dot(power)

            return result[0][0]
