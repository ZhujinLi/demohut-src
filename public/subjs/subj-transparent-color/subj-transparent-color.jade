extends /layout

block subj-title
    p Transparent color matters

block content
    p Consider a simple 2x2 texture consisting of two opaque red texels(1,0,0,1) and two transparent texels(0,0,0,0):

    img(src='/subjs/subj-transparent-color/2x2-mag.png', width='60')

    p If we are going to magnify this 2x2 texture and map it to a larger area (say 128x128), this is what we expect to see (generated by Photoshop):

    img(src='/subjs/subj-transparent-color/2x2-expected.png', width='200')

    p But when trying so with OpenGL (or WebGL which I'm using here), you'll get something strange instead:

    div(style="position: relative;")
        canvas#view-bad(width='200', height='200')
    
    p There are some unwanted black fringes around the red blocks. What happens there?

    .sub-title Texture sampling

    p The rendering pipeline samples a magnified texture in a quite straight-forward manner: just performing a linear combination on neighboring texels' RGBA values, separately. For instance, in the middle between a red texel and a transparent one, the rendering pipeline computes the output color as:
    
    p.text-center 0.5*(1,0,0,1) + 0.5*(0,0,0,0) = (0.5,0,0,0.5)

    p Now it's clear where the black comes from—those transparent, invisible texels! Their color matters. Blending a red color and transparent ought to produce a translucent 'proper red', like (1,0,0,0.5), but the pipeline gives a translucent 'dark red' (0.5,0,0,0.5). This is wrong.
    
    p And this "black fringing" artifact is very common in real time rendering. Here's one another:
    
    img(src='/subjs/subj-transparent-color/mush_bad.png', width='200')
    
    p Is the graphics pipeline to be blame? No, it's just doing its job, although some software implementations could handle this perfectly. So how do we avoid this problem without touching the graphics driver? There are two mainstream methods.
    
    .sub-title Method 1: texture bleeding

    p Since the black comes from texels whose alpha is 0, we can simply modify the texture and turn these texels' RGB to red, and the resulting RGB would be red anyway:

    p.text-center 0.5*(1,0,0,1) + 0.5*(1,0,0,0) = (1,0,0,0.5)

    p 'Bleeding' means spreading the RGB of the object's solid-color edge texels to nearby transparent ones, while maintaining their alpha 0. If you are going to use the texture's mipmaps, make the bleeding range as large as possible.

    p Experiment with WebGL, it's indeed working:

    div(style="position: relative;")
        canvas#view-bleeding(width='200', height='200')

    .sub-title Method 2: premultiplied alpha

    p Let's change the 2x2 texture a bit: make the two fully transparent pixels slight green (0,1,0,0.1), which is barely noticeable.
    
    img(src='/subjs/subj-transparent-color/2x2-green.png', width='60')

    p Unsurprisingly, the GPU gives us the familiar artifact:

    div(style="position: relative;")
        canvas#view-green-bad(width='200', height='200')

    p Let's inspect the formula once again:

    p.text-center 0.5*(1,0,0,1) + 0.5*(0,1,0,0.1) = (0.5,0.5,0,0.55)

    p The biggest problem here is the resulting green shares the same weight as the red channel, even if it comes from such a trivial source. It's natural for us to consider giving less weight of tinge to texels with smaller alpha. What if we multiply RGB with A, and represent the color from (R,G,B,A) to (RA,GA,BA,A)?

    p.text-center 0.5*(1,0,0,1) + 0.5*(0,0.1,0,0.1) = (0.5,0.05,0,0.55)

    p Okay, now the green is significantly reduced, which is good. However, the red component seems to be incorrect—it should be 1. Note the above representation is based on (RA,GA,BA,A), so we need to restore to (R,G,B,A) by dividing RGB by A, which is (0.91,0.09,0,0.55). Seems right now.
    
    p This representation is called "premultiplied alpha", in contrast to "straight alpha", "unassociated alpha", "separate alpha"... whatever you call it.

    p To convert to premultiplied space, we need to alter the texels in PNG, or process them when reading them into memory. But how do we convert them back to normal (R,G,B,A) representation in the end?
    
    p In rendering pipeline, the final color of a pixel is to be blended with the one already in the framebuffer. This process is called blending. In OpenGL, the default blending function (we only discuss RGB here) is:
    
    p.text-center d_RGB = (s_RGB * GL_SRC_ALPHA) + (d_RGB * GL_ONE_MINUS_SRC_ALPHA)

    p In premultiplied world, the color outputted from the fragment shader is (RA,GA,BA,A), which needs to be restored before blending:
    
    p.text-center d_RGB = (s_RGB / s_A * GL_SRC_ALPHA) + (d_RGB * GL_ONE_MINUS_SRC_ALPHA)

    p And it can be further simplified:

    p.text-center d_RGB = (s_RGB * GL_ONE) + (d_RGB * GL_ONE_MINUS_SRC_ALPHA)

    p So, all we have to do is change the blending function.

    p Let's do the experiment using WebGL again:

    div(style="position: relative;")
        canvas#view-green-pma(width='200', height='200')

    p Dark fringes disappeared.

    p To sum up, the premultiplied alpha approach involves two operations:

    ol
        li Premultiply texels in the texture file
        li Change the rendering pipeline blending function

    .sub-title Notes

    ul
        li WebGL behaves differently from OpenGL in some aspects. For example, the canvas is composited over the HTML page using premultiplied alpha blending by default. Hence, in the demos above, I turn off the alpha channel writing mask to make a clearer elaboration. See the code for details.
        li There are more discussions in #[a(href='http://www.realtimerendering.com/blog/gpus-prefer-premultiplication/' target='_blank') GPUs prefer premultiplication]


    script(src='/subjs/subj-transparent-color/main.js', type='module')
