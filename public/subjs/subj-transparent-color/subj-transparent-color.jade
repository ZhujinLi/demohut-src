extends /layout

block subj-title
    p Transparent color matters

block content
    p Consider a simple 2x2 texture consisting of two opaque red texels(1,0,0,1) and two transparent texels(0,0,0,0):

    img(src='/public/subjs/subj-transparent-color/2x2-mag.png', width='60')

    p If we are going to magnify this 2x2 texture and map it to a larger area (say 128x128), we expect to see this (generated by Photoshop):

    img(src='/public/subjs/subj-transparent-color/2x2-expected.png', width='200')

    p But when trying so with OpenGL (or WebGL which I'm using here), you'll get something strange instead:

    div(style="position: relative;")
        canvas#view-bad(width='200', height='200')
    
    p There are some unwanted black fringes around the red blocks. What happens there?

    .sub-title Texture sampling

    p The rendering pipeline samples a magnified texture in a quite straight-forward manner: just performing a linear combination on neighboring texels' RGBA values, separately. For instance, in the middle between a red texel and a transparent one, the rendering pipeline computes the output color as:
    
    p.text-center 0.5*(1,0,0,1) + 0.5*(0,0,0,0) = (0.5,0,0,0.5)

    p Now it's clear where the black comes from—those transparent, invisible texels! Their color matters. Blending a red color and transparent ought to produce a translucent 'proper red', like (1,0,0,0.5), but the pipeline gives a translucent 'dark red' (0.5,0,0,0.5). This is wrong.
    
    p And this "black fringing" artifact is very common in real time rendering. Here's one another:
    
    img(src='/public/subjs/subj-transparent-color/mush_bad.png', width='200')
    
    p Is the graphics pipeline to be blame? No, it's just doing its job, although some software implementations could handle this perfectly. So how do we avoid this problem without touching the graphics driver? There are two mainstream methods.
    
    .sub-title Method 1: texture bleeding

    p Since the black comes from texels whose alpha is 0, we can simply modify the texture and turn these texels' RGB to red, and the resulting RGB would be red anyway:

    p.text-center 0.5*(1,0,0,1) + 0.5*(1,0,0,0) = (1,0,0,0.5)

    p Experiment with WebGL, it's indeed working:

    div(style="position: relative;")
        canvas#view-bleeding(width='200', height='200')

    p 'Bleeding' means spreading the RGB of the object's solid-color edge texels to nearby transparent ones, while maintaining their alpha 0. This can be done with some image processing tools like Photoshop, here's an example:
    
    img(src='/public/subjs/subj-transparent-color/bleeding-demo.png', width='300')

    p The original icon area is expanded by 1 texel, and these expanded texels are assigned corresponding RGB values. Here for illurstration purpose I make these texels visible, though in reality they are fully transparent. If you are going to use the texture's mipmaps, make the bleeding range as large as possible. Otherwise this 1 texel border is sufficient.

    .sub-title Method 2: premultiplied alpha

    p Let's change the 2x2 texture a bit: make the two fully transparent pixels slight green (0,1,0,0.1), which is barely noticeable.
    
    img(src='/public/subjs/subj-transparent-color/2x2-green.png', width='60')

    p Unsurprisingly, the GPU gives us the familiar artifact:

    div(style="position: relative;")
        canvas#view-green-bad(width='200', height='200')

    p Let's inspect the formula once again:

    p.text-center 0.5*(1,0,0,1) + 0.5*(0,1,0,0.1) = (0.5,0.5,0,0.55)

    p The biggest problem here is the resulting green shares the same weight as the red channel, even if it comes from such a trivial source. It's natural for us to consider giving less weight of tinge to texels with smaller alpha. What if we multiply RGB by A, and represent the color with (RA,GA,BA,A) instead of (R,G,B,A)?

    p.text-center 0.5*(1,0,0,1) + 0.5*(0,0.1,0,0.1) = (0.5,0.05,0,0.55)

    p Okay, now the green is significantly reduced, which is good. However, the red component seems incorrect—it should be 1 or something. Note the above representation is based on (RA,GA,BA,A), so we need to restore it to (R,G,B,A) by dividing RGB by A, which turns out to be (0.91,0.09,0,0.55). Seems right now.
    
    p The representation (RA,GA,BA,A) is called "premultiplied alpha", in contrast to "straight alpha", "unassociated alpha", or "separate alpha"... Whatever you call it.

    p To enter the premultiplied space, we need to alter the texels in PNG, or process them when reading them into memory. But how do we convert them back to straight (R,G,B,A) representation in the end?
    
    p In rendering pipeline, the final color of a pixel is to be blended with the one already in the framebuffer. In OpenGL, the default blending function is (we only discuss RGB here):
    
    p.text-center d_RGB = (s_RGB * GL_SRC_ALPHA) + (d_RGB * GL_ONE_MINUS_SRC_ALPHA)

    p In premultiplied world, the color outputted from the fragment shader is (RA,GA,BA,A), which needs to be restored before blending:
    
    p.text-center d_RGB = (s_RGB / s_A * GL_SRC_ALPHA) + (d_RGB * GL_ONE_MINUS_SRC_ALPHA)

    p And it can be further simplified:

    p.text-center d_RGB = (s_RGB * GL_ONE) + (d_RGB * GL_ONE_MINUS_SRC_ALPHA)

    p So, all we have to do is change the blending function.

    p Let's do the experiment using WebGL again:

    div(style="position: relative;")
        canvas#view-green-pma(width='200', height='200')

    p Perfect. Dark fringes disappeared.

    p To sum up, the premultiplied alpha approach involves two operations:

    ol
        li Premultiply texels in the texture file
        li Change the rendering pipeline blending function

    .sub-title Notes

    ul
        li WebGL behaves differently from OpenGL in some aspects. For example, the canvas is composited over the HTML page assuming premultiplied alpha by default. Hence, in the demos above, I turn off the alpha channel writing mask for a clearer elaboration. See the code for details.
        li There are more discussions in #[a(href='http://www.realtimerendering.com/blog/gpus-prefer-premultiplication/' target='_blank') GPUs prefer premultiplication]


    script(src='/public/subjs/subj-transparent-color/main.js', type='module')
